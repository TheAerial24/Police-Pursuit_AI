<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Dogfight Destruction v1.0</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  *{box-sizing:border-box;margin:0;padding:0;}
  html,body{width:100%;height:100%;overflow:hidden;font-family:'Inter',sans-serif;background:#60A5FA;color:#0b2447;}
  #gameCanvas{display:block;background:#bfdbfe;position:absolute;top:0;left:0;z-index:1;}
  .ui-container{position:absolute;top:0;left:0;width:100%;height:100%;z-index:4;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;align-items:center;}
  #scoreDisplay{font-size:2.4rem;font-weight:900;margin-top:1.5rem;text-shadow:0 0 8px rgba(255,255,255,0.3);pointer-events:auto;color:#0b2447;}
  #messageOverlay{font-size:1.1rem;font-weight:700;text-align:center;animation:pulse 2s infinite;pointer-events:auto;color:#07203b;}
  @keyframes pulse{0%{opacity:1;transform:scale(1);}50%{opacity:0.8;transform:scale(1.02);}100%{opacity:1;}}
  #gameOverModal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:6;background-color:#111827;padding:2rem;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.45);text-align:center;display:none;pointer-events:auto;color:#e6eef9;}
  #gameOverModal h1{font-size:2rem;margin-bottom:0.5rem;}
  #gameOverModal p{font-size:1rem;margin-bottom:1rem;color:#cbd5e1;}
  #restartButton{font-family:'Inter',sans-serif;background:#3B82F6;color:white;border:none;padding:0.8rem 1.4rem;border-radius:8px;font-size:1rem;font-weight:800;cursor:pointer;transition:all 0.18s ease;box-shadow:0 6px 18px rgba(59,130,246,0.25);}
  #restartButton:hover{transform:translateY(-3px); background:#2563EB;}
  .touch-zone{position:absolute;top:0;width:50%;height:100%;z-index:3;pointer-events:auto;}
  #touchLeft{left:0;}
  #touchRight{right:0;}
  .hint { position:absolute; bottom:18px; left:50%; transform:translateX(-50%); font-weight:700; pointer-events:none; color:rgba(3,37,65,0.9);}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div class="touch-zone" id="touchLeft"></div>
<div class="touch-zone" id="touchRight"></div>

<div class="ui-container">
  <div id="scoreDisplay">0</div>
  <div id="messageOverlay">Tap/Press Left/Right to Steer-Spacebar to Shoot · Press any key to Start<br>Press <strong>P</strong> to Pause</div>
</div>

<div id="gameOverModal">
  <h1>Game Over</h1>
  <p>Your final score is: <strong><span id="finalScore">0</span></strong></p>
  <p>High Score: <strong><span id="bestScore">0</span></strong></p>
  <button id="restartButton">Retry</button>
</div>

<script>
/* ============================
    Setup + constants
    ============================ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('scoreDisplay');
const messageOverlay = document.getElementById('messageOverlay');
const gameOverModal = document.getElementById('gameOverModal');
const finalScoreDisplay = document.getElementById('finalScore');
const bestScoreDisplay = document.getElementById('bestScore');
const restartButton = document.getElementById('restartButton');
const touchLeft = document.getElementById('touchLeft');
const touchRight = document.getElementById('touchRight');

let gameState = 'menu'; // menu | playing | paused | gameOver
let score = 0, lastTime = 0, gameTime = 0;

/* === Anti-Cheat Vars === */
let antiCheatTimer = 0;
let turnCheatTimer = 0;
let fireCheatTimer = 0; // <-- NEW: Timer for fire-only cheat
let antiCheatTriggered = false;

const camera = { x:0, y:0 };
const PLAYER_SPEED = 120;
const PLAYER_TURN_SPEED = 3.5;
const JET_WIDTH = 48, JET_HEIGHT = 48, JET_RADIUS = 16;
const ENEMY_SPEED = 120, ENEMY_TURN_SPEED = 2.1;
const MAX_ENEMIES = 5;
let spawnTimer = 0, spawnInterval = 4.5;

const input = { left:false, right:false, fire:false };
let player = null, enemies = [], particles = [], contrails = [], bullets = [];
let lastShotTime = 0, SHOT_COOLDOWN = 5 /*ms*/, BULLET_SPEED = 2400, BULLET_RADIUS = 5;
let highScore = Number(localStorage.getItem('jet_dogfight_high') || 0);

const MINIMAP_SCOPE = 4000;
const ENEMY_SPAWN_INVULN = 1.5;
const DEBUG = false;

/* ============================
    Inline SVG sprites -> data URLs
    ============================ */
const svgPlayer = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#3B82F6" stroke="#1e3a8a" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#60A5FA"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#93C5FD"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#1e3a8a" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#1e3a8a" opacity="0.6"/>
  </g>
</svg>`;

const svgEnemy = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#EF4444" stroke="#7f1d1d" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#F87171"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#FECACA"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#7f1d1d" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#7f1d1d" opacity="0.6"/>
  </g>
</svg>`;

function svgToImg(svgString, onload) {
  const img = new Image();
  img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);
  img.onload = () => { if (onload) onload(img); };
  img.onerror = () => { console.warn('Failed to load inline SVG image.'); if (onload) onload(img); };
  return img;
}

const imgPlayerJet = svgToImg(svgPlayer);
const imgEnemyJet  = svgToImg(svgEnemy);

/* ============================
    Utility helpers
    ============================ */
function resizeCanvas(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
function rand(min,max){ return Math.random()*(max-min)+min; }
function getDistance(x1,y1,x2,y2){ return Math.hypot(x2 - x1, y2 - y1); }
function wrapAngle(a){ return (a + Math.PI) % (Math.PI*2) - Math.PI; }
function createJet(x,y,angle,speed,turnSpeed,color,type){
  return { x,y,angle,speed,turnSpeed,color,type,width:JET_WIDTH,height:JET_HEIGHT,radius:JET_RADIUS,velX:0,velY:0,spawnTime:gameTime };
}

/* ============================
    Game lifecycle
    ============================ */
function resetGame(){
  player = createJet(0,0,-Math.PI/2,PLAYER_SPEED,PLAYER_TURN_SPEED,'#3B82F6','player');
  enemies = []; particles = []; contrails = []; bullets = [];
  score = 0; gameTime = 0; spawnTimer = 1.8; spawnInterval = 4.5;
  gameState = 'playing';
  gameOverModal.style.display = 'none';
  messageOverlay.style.display = 'none';
  scoreDisplay.style.display = 'block';
  // reset anti-cheat tracking
  antiCheatTimer = 0;
  turnCheatTimer = 0;
  fireCheatTimer = 0; // <-- NEW: Reset new timer
  antiCheatTriggered = false;
}

function spawnEnemy(){
  if (enemies.length >= MAX_ENEMIES) return;
  const spawnAngle = Math.random()*Math.PI*2;
  const spawnDist = Math.max(canvas.width, canvas.height)*0.8;
  const x = player.x + Math.cos(spawnAngle)*spawnDist;
  const y = player.y + Math.sin(spawnAngle)*spawnDist;
  const angle = Math.atan2(player.y - y, player.x - x);
  enemies.push(createJet(x,y,angle,ENEMY_SPEED,ENEMY_TURN_SPEED,'#EF4444','enemy'));
}

function createExplosion(x,y,count){
  for(let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = rand(40,220);
    const life = rand(0.6,1.6);
    particles.push({ x,y,dx:Math.cos(angle)*speed,dy:Math.sin(angle)*speed,life,maxLife:life,size:rand(2,5) });
  }
}

function showGameOver(){
  gameState = 'gameOver';
  scoreDisplay.style.display = 'none';
  messageOverlay.style.display = 'none';
  finalScoreDisplay.textContent = score;
  if (score > highScore){ highScore = score; localStorage.setItem('jet_dogfight_high', highScore); }
  bestScoreDisplay.textContent = highScore;
  gameOverModal.style.display = 'block';
  gameOverModal.querySelector('h1').textContent = 'Game Over';
}

/* ============================
    Anti-Cheat: Special end screen
    ============================ */
function showAntiCheat(){
  gameState = 'gameOver';
  scoreDisplay.style.display = 'none';
  messageOverlay.style.display = 'none';
  finalScoreDisplay.textContent = score;
  if (score > highScore){ highScore = score; localStorage.setItem('jet_dogfight_high', highScore); }
  bestScoreDisplay.textContent = highScore;
  gameOverModal.style.display = 'block';
  gameOverModal.querySelector('h1').textContent = 'Anti Cheat Is: Active';
  restartButton.textContent = 'Restart Game';
}

/* ============================
    Drawing jets using images
    ============================ */
function drawJet(ctx, ent){
  ctx.save();
  ctx.translate(ent.x, ent.y);
  ctx.rotate(ent.angle);
  const img = ent.type === 'player' ? imgPlayerJet : imgEnemyJet;
  const w = ent.width;
  const h = ent.height;
  if (img && img.complete && img.width){
    ctx.drawImage(img, -w/2, -h/2, w, h);
  } else {
    ctx.fillStyle = ent.color;
    ctx.beginPath();
    ctx.moveTo(h/2,0);
    ctx.lineTo(-h/2, w/2);
    ctx.lineTo(-h/3,0);
    ctx.lineTo(-h/2, -w/2);
    ctx.closePath();
    ctx.fill();
  }
  if (ent.type === 'enemy' && gameTime - ent.spawnTime < ENEMY_SPAWN_INVULN) {
    ctx.globalAlpha = 0.6;
  }
  if (DEBUG){
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0,0,ent.radius,0,Math.PI*2);
    ctx.stroke();
  }
  ctx.restore();
}

/* ============================
    Update loop
    ============================ */
function update(dt){
  if (!dt || isNaN(dt)) return;
  if (gameState !== 'playing') return;
  gameTime += dt;

  // === Anti-Cheat: Holding turn for 10 seconds ===
  if (input.left || input.right) {
    turnCheatTimer += dt;
    if (turnCheatTimer >= 10 && !antiCheatTriggered) {
      antiCheatTriggered = true;
      createExplosion(player.x, player.y, 30);
      showAntiCheat();
      return; // stop further updates
    }
  } else {
    turnCheatTimer = 0;
  }

  // === Anti-cheat: Holding fire + left/right continuously for 5 seconds ===
  if (input.fire && (input.left || input.right)) {
    antiCheatTimer += dt;
    if (antiCheatTimer >= 5 && !antiCheatTriggered) {
      antiCheatTriggered = true;
      createExplosion(player.x, player.y, 30);
      showAntiCheat();
      return; // stop further updates after anti-cheat triggers
    }
  } else {
    antiCheatTimer = 0;
  }
  
  // === NEW Anti-Cheat: Holding fire for 10 seconds ===
  if (input.fire) {
    fireCheatTimer += dt;
    if (fireCheatTimer >= 10 && !antiCheatTriggered) {
      antiCheatTriggered = true;
      createExplosion(player.x, player.y, 30);
      showAntiCheat();
      return; // stop further updates
    }
  } else {
    fireCheatTimer = 0;
  }

  // player steering & drift
  if (input.left) player.angle -= player.turnSpeed * dt;
  if (input.right) player.angle += player.turnSpeed * dt;
  player.velX += Math.cos(player.angle) * player.speed * dt * 0.55;
  player.velY += Math.sin(player.angle) * player.speed * dt * 0.55;
  player.velX *= 0.92;
  player.velY *= 0.92;
  player.x += player.velX;
  player.y += player.velY;

  // contrails
  contrails.push({ x:player.x, y:player.y, angle:player.angle, life:1 });
  if (contrails.length > 360) contrails.shift();

  // enemies AI
  for (let i=enemies.length-1;i>=0;i--){
    let e = enemies[i];
    const targ = Math.atan2(player.y - e.y, player.x - e.x);
    let diff = wrapAngle(targ - e.angle);
    const dir = Math.sign(diff);
    e.angle += Math.min(Math.abs(diff), e.turnSpeed * dt) * dir;
    e.x += Math.cos(e.angle) * e.speed * dt;
    e.y += Math.sin(e.angle) * e.speed * dt;
  }

  // spawn enemies
  spawnTimer -= dt;
  if (spawnTimer <= 0){
    spawnEnemy();
    spawnTimer = spawnInterval;
    if (spawnInterval > 1.2) spawnInterval *= 0.97;
  }

  // collisions: enemy vs enemy
  for (let i = enemies.length - 1; i >= 0; i--){
    for (let j = i-1; j >= 0; j--){
      if (i >= enemies.length || j >= enemies.length) continue;
      let a = enemies[i], b = enemies[j];
      if (gameTime - a.spawnTime < ENEMY_SPAWN_INVULN || gameTime - b.spawnTime < ENEMY_SPAWN_INVULN) continue;
      if (getDistance(a.x,a.y,b.x,b.y) < a.radius + b.radius){
        createExplosion(a.x,a.y,12);
        createExplosion(b.x,b.y,12);
        enemies.splice(i,1);
        enemies.splice(j,1);
        score += 200;
        break;
      }
    }
  }

  // collisions: player vs enemy
  for (let i = enemies.length -1; i>=0; i--){
    const e = enemies[i];
    if (gameTime - e.spawnTime < ENEMY_SPAWN_INVULN) continue;
    if (getDistance(player.x,player.y,e.x,e.y) < player.radius + e.radius){
      createExplosion(player.x,player.y,28);
      showGameOver();
      return;
    }
  }

  // particles update
  for (let i = particles.length-1; i>=0; i--){
    let p = particles[i];
    p.x += p.dx * dt; p.y += p.dy * dt; p.life -= dt;
    if (p.life <= 0) particles.splice(i,1);
  }

  // firing
  if (input.fire){
    if (performance.now() - lastShotTime > SHOT_COOLDOWN){
      spawnBulletFromJet(player);
      lastShotTime = performance.now();
    }
  }

  // bullets update + collisions vs enemies
  for (let i = bullets.length-1; i>=0; i--){
    let b = bullets[i];
    b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
    if (b.life <= 0){ bullets.splice(i,1); continue; }
    for (let j = enemies.length-1; j>=0; j--){
      let e = enemies[j];
      if (getDistance(b.x,b.y,e.x,e.y) < BULLET_RADIUS + e.radius){
        createExplosion(e.x,e.y,14);
        enemies.splice(j,1);
        bullets.splice(i,1);
        score += 100;
        break;
      }
    }
  }

  scoreDisplay.textContent = score;
}

/* ============================
    Mini map
    ============================ */
function drawMiniMap(){
  const mapSize = 140; const mapMargin = 16;
  const mapX = canvas.width - mapSize - mapMargin; const mapY = mapMargin;
  const scale = mapSize / MINIMAP_SCOPE;
  ctx.save(); ctx.translate(mapX,mapY);
  ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.fillRect(0,0,mapSize,mapSize);
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.6; ctx.strokeRect(0,0,mapSize,mapSize);
  // player dot center
  ctx.globalAlpha = 1.0;
  ctx.fillStyle = player.color; ctx.beginPath(); ctx.arc(mapSize/2, mapSize/2, 3, 0, Math.PI*2); ctx.fill();
  for (let e of enemies){
    const rx = e.x - player.x, ry = e.y - player.y;
    const dx = (rx * scale) + (mapSize/2), dy = (ry * scale) + (mapSize/2);
    ctx.globalAlpha = (gameTime - e.spawnTime < ENEMY_SPAWN_INVULN) ? 0.5 : 1.0;
    if (dx > 0 && dx < mapSize && dy > 0 && dy < mapSize){
      ctx.fillStyle = '#EF4444'; ctx.beginPath(); ctx.arc(dx,dy,2,0,Math.PI*2); ctx.fill();
    }
  }
  ctx.globalAlpha = 1.0; ctx.restore();
}

/* ============================
    Draw everything
    ============================ */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  camera.x = (player && player.x !== undefined) ? player.x : 0;
  camera.y = (player && player.y !== undefined) ? player.y : 0;

  ctx.save();
  ctx.translate(canvas.width/2 - camera.x, canvas.height/2 - camera.y);

  // contrails
  for (let s of contrails){
    s.life -= 0.02;
    ctx.save();
    ctx.translate(s.x, s.y); ctx.rotate(s.angle);
    ctx.fillStyle = `rgba(255,255,255,${Math.max(0, s.life * 0.45)})`;
    ctx.fillRect(-12, -2.5, 24, 5);
    ctx.restore();
  }

  // particles
  for (let p of particles){
    ctx.fillStyle = `rgba(255,165,0,${Math.max(0, p.life/p.maxLife)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
  }

  // bullets
  for (let b of bullets){
    ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(b.x,b.y,BULLET_RADIUS,0,Math.PI*2); ctx.fill();
  }

  // draw jets
  if (player && player.x !== undefined) drawJet(ctx, player);
  for (let e of enemies) drawJet(ctx, e);

  ctx.restore();

  if (player && player.x !== undefined) drawMiniMap();
}

/* ============================
    Input handlers & spawn bullets
    ============================ */
restartButton.addEventListener('click', resetGame);
window.addEventListener('resize', resizeCanvas);

window.addEventListener('keydown', e => {
  if (gameState === 'menu'){
    resetGame(); return;
  }

  if ((e.key === 'p' || e.key === 'P')) {
    if (gameState === 'playing') {
      gameState = 'paused';
      messageOverlay.textContent = 'PAUSED · Press P to Resume';
      messageOverlay.style.display = 'block';
    } else if (gameState === 'paused') {
      gameState = 'playing';
      messageOverlay.style.display = 'none';
    }
  }

  if (e.key === 'ArrowLeft') input.left = true;
  if (e.key === 'ArrowRight') input.right = true;
  if (e.code === 'Space') input.fire = true;
});

window.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft') input.left = false;
  if (e.key === 'ArrowRight') input.right = false;
  if (e.code === 'Space') input.fire = false;
});

touchLeft.addEventListener('touchstart', e => { e.preventDefault(); input.left = true; if (gameState === 'menu') resetGame(); }, { passive:false });
touchLeft.addEventListener('touchend',   e => { e.preventDefault(); input.left = false; }, { passive:false });
touchRight.addEventListener('touchstart', e => { e.preventDefault(); input.right = true; if (gameState === 'menu') resetGame(); }, { passive:false });
touchRight.addEventListener('touchend',   e => { e.preventDefault(); input.right = false; }, { passive:false });

function spawnBulletFromJet(jet){
  const nose = (jet.height/2) + 6;
  const bx = jet.x + Math.cos(jet.angle) * nose;
  const by = jet.y + Math.sin(jet.angle) * nose;
  bullets.push({ x:bx, y:by, vx:Math.cos(jet.angle)*BULLET_SPEED, vy:Math.sin(jet.angle)*BULLET_SPEED, life:2.2 });
}

function spawnBulletFromCar(car){ spawnBulletFromJet(car); }

/* ============================
    Main loop start
    ============================ */
resizeCanvas();
lastTime = performance.now();
requestAnimationFrame(function loop(t){
  const dt = (t - lastTime) / 1000;
  lastTime = t;
  if (gameState === 'playing') update(dt);
  draw();
  requestAnimationFrame(loop);
});

/* Set initial UI values */
scoreDisplay.textContent = score;
bestScoreDisplay.textContent = highScore;
messageOverlay.style.display = 'block';
</script>

<!-- ============================
     APPENDED: Overheat / Cooldown plugin (unchanged, as you liked)
     ============================ -->
<script>
(function(){
  const SHOOT_LIMIT = 5.0;
  const COOLDOWN = 10.0;
  const BAR_BG = 'rgba(0,0,0,0.36)';
  const BAR_FILL = 'linear-gradient(90deg, #f43f5e 0%, #fb923c 100%)';

  let shootTimer = 0;
  let cooldownTimer = 0;
  let state = 'ready';

  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.bottom = '12px';
  container.style.left = '50%';
  container.style.transform = 'translateX(-50%)';
  container.style.width = '220px';
  container.style.height = '14px';
  container.style.background = BAR_BG;
  container.style.borderRadius = '8px';
  container.style.overflow = 'hidden';
  container.style.zIndex = '1000';
  container.style.pointerEvents = 'none';
  document.body.appendChild(container);

  const fill = document.createElement('div');
  fill.style.height = '100%';
  fill.style.width = '100%';
  fill.style.background = BAR_FILL;
  fill.style.transition = 'width 0.06s linear';
  container.appendChild(fill);

  if (typeof spawnBulletFromJet === 'function') {
    const originalSpawn = spawnBulletFromJet;
    window.spawnBulletFromJet = function(jet){
      if (state === 'cooldown') return;
      return originalSpawn.call(this, jet);
    };
  }

  const originalUpdate = window.update;
  if (typeof originalUpdate !== 'function') return;

  window.update = function(dt){
    originalUpdate(dt);

    if (state === 'ready') {
      if (input.fire) {
        shootTimer += dt;
        if (shootTimer >= SHOOT_LIMIT) {
          state = 'cooldown';
          cooldownTimer = COOLDOWN;
        }
      }
    } else if (state === 'cooldown') {
      cooldownTimer -= dt;
      if (cooldownTimer <= 0) {
        cooldownTimer = 0;
        shootTimer = 0;
        state = 'ready';
      }
    }

    if (state === 'ready') {
      const rem = Math.max(0, (SHOOT_LIMIT - shootTimer) / SHOOT_LIMIT);
      fill.style.width = (rem * 100) + '%';
      fill.style.background = BAR_FILL;
    } else {
      const filled = Math.min(1, (COOLDOWN - cooldownTimer) / COOLDOWN);
      fill.style.width = (filled * 100) + '%';
      fill.style.background = BAR_FILL;
    }
  };
})();
</script>

<!-- ============================
     APPENDED: Boss System plugin (flying @ 5000, turret @ 10000)
     No edits to original code.
     ============================ -->
<script>
(function(){
  // Config
  const BOSS1_SCORE = 5000;   // Flying boss
  const BOSS2_SCORE = 10000;  // Stationary turret boss
  const BOSS_BONUS = 2000;

  // Flying boss config (2x size of enemy)
  const BOSS_JET = {
    width: 48*2, height: 48*2, radius: 16*2,
    speed: 150, turnSpeed: 2.3, color: '#DC2626', type:'bossJet',
    maxHp: 40  // needs 40 bullet hits (tune as desired)
  };

  // Turret boss config
  const BOSS_TURRET = {
    radius: 40, type:'bossTurret', maxHp: 60,
    fireCooldown: 0.8, projectileSpeed: 420, projectileRadius: 6
  };

  const HP_BAR = { w: 360, h: 16, y: 18, bg:'rgba(0,0,0,0.35)', fill:'#ef4444', stroke:'#111' };

  const state = {
    active: false,
    current: null, // the boss entity
    type: null,
    defeatedJet: false,
    defeatedTurret: false,
    bossShots: []
  };

  // Prevent regular enemy spawns while boss is active
  if (typeof spawnEnemy === 'function') {
    const origSpawnEnemy = spawnEnemy;
    window.spawnEnemy = function(){
      if (state.active) return; // block spawning during boss
      return origSpawnEnemy.apply(this, arguments);
    };
  }

  // Reset boss state on resetGame
  if (typeof resetGame === 'function') {
    const origReset = resetGame;
    window.resetGame = function(){
      state.active = false;
      state.current = null;
      state.type = null;
      state.bossShots.length = 0;
      // DO NOT reset defeated flags here so score thresholds still work after death
      return origReset.apply(this, arguments);
    };
  }

  function spawnBossJet(){
    // Spawn just offscreen, similar to enemies
    const spawnAngle = Math.random()*Math.PI*2;
    const spawnDist = Math.max(canvas.width, canvas.height)*0.8;
    const x = player.x + Math.cos(spawnAngle)*spawnDist;
    const y = player.y + Math.sin(spawnAngle)*spawnDist;
    const angle = Math.atan2(player.y - y, player.x - x);
    state.current = {
      x, y, angle,
      speed: BOSS_JET.speed,
      turnSpeed: BOSS_JET.turnSpeed,
      width: BOSS_JET.width,
      height: BOSS_JET.height,
      radius: BOSS_JET.radius,
      color: BOSS_JET.color,
      type: BOSS_JET.type,
      hp: BOSS_JET.maxHp, maxHp: BOSS_JET.maxHp
    };
    state.type = 'jet';
    state.active = true;
  }

  function spawnBossTurret(){
    // Place near map center relative to player
    const x = player.x + 0; 
    const y = player.y - 120; // just above player start area
    state.current = {
      x, y, angle: 0,
      type: BOSS_TURRET.type,
      hp: BOSS_TURRET.maxHp, maxHp: BOSS_TURRET.maxHp,
      fireTimer: 0
    };
    state.type = 'turret';
    state.active = true;
  }

  function bossUpdate(dt){
    if (!state.active || !state.current) return;

    if (state.type === 'jet'){
      // Chase player (similar to enemy AI but beefier)
      const b = state.current;
      const targ = Math.atan2(player.y - b.y, player.x - b.x);
      let diff = ((targ - b.angle + Math.PI) % (Math.PI*2)) - Math.PI;
      b.angle += Math.min(Math.abs(diff), b.turnSpeed * dt) * Math.sign(diff);
      b.x += Math.cos(b.angle) * b.speed * dt;
      b.y += Math.sin(b.angle) * b.speed * dt;
    } else if (state.type === 'turret'){
      // Rotate to face player and fire projectiles
      const b = state.current;
      b.angle = Math.atan2(player.y - b.y, player.x - b.x);
      b.fireTimer -= dt;
      if (b.fireTimer <= 0){
        b.fireTimer = BOSS_TURRET.fireCooldown;
        // Fire a projectile towards player
        const vx = Math.cos(b.angle) * BOSS_TURRET.projectileSpeed;
        const vy = Math.sin(b.angle) * BOSS_TURRET.projectileSpeed;
        state.bossShots.push({ x: b.x, y: b.y, vx, vy, r: BOSS_TURRET.projectileRadius, life: 6 });
      }
    }

    // Boss shots update & player collision
    for (let i=state.bossShots.length-1; i>=0; i--){
      const s = state.bossShots[i];
      s.x += s.vx * dt; s.y += s.vy * dt; s.life -= dt;
      if (s.life <= 0){ state.bossShots.splice(i,1); continue; }
      // collision vs player
      const d = Math.hypot(s.x - player.x, s.y - player.y);
      if (d < (s.r + player.radius)){
        createExplosion(player.x, player.y, 28);
        showGameOver();
        return; // stop further processing this frame
      }
    }

    // Player bullets vs boss collision
    for (let i=bullets.length-1; i>=0; i--){
      const b = bullets[i];
      const dx = b.x - state.current.x;
      const dy = b.y - state.current.y;
      const dist = Math.hypot(dx, dy);
      const hitR = (state.type === 'jet') ? state.current.radius : BOSS_TURRET.radius;
      if (dist < (BULLET_RADIUS + hitR)){
        bullets.splice(i,1);
        state.current.hp -= 1; // each bullet = 1 damage (tune if needed)
        // small hit explosion
        particles.push({ x: b.x, y: b.y, dx: rand(-60,60), dy: rand(-60,60), life: 0.3, maxLife: 0.3, size: 3 });
        if (state.current.hp <= 0){
          // Big boom, bonus, clear boss
          createExplosion(state.current.x, state.current.y, 60);
          score += BOSS_BONUS;
          state.active = false;
          if (state.type === 'jet') state.defeatedJet = true;
          if (state.type === 'turret') state.defeatedTurret = true;
          state.type = null;
          state.current = null;
          state.bossShots.length = 0;
          break;
        }
      }
    }
  }

  function bossDraw(){
    if (!state.active || !state.current) return;

    // Draw world-space stuff with same camera transform as your draw()
    ctx.save();
    ctx.translate(canvas.width/2 - camera.x, canvas.height/2 - camera.y);

    if (state.type === 'jet'){
      const b = state.current;
      // Draw big red jet using enemy sprite scaled up
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.angle);
      const img = imgEnemyJet;
      const w = b.width, h = b.height;
      if (img && img.complete && img.width){
        ctx.drawImage(img, -w/2, -h/2, w, h);
      } else {
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.moveTo(h/2,0);
        ctx.lineTo(-h/2, w/2);
        ctx.lineTo(-h/3,0);
        ctx.lineTo(-h/2, -w/2);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    } else if (state.type === 'turret'){
      const b = state.current;
      // Base
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.fillStyle = '#7f1d1d';
      ctx.beginPath(); ctx.arc(0,0,BOSS_TURRET.radius,0,Math.PI*2); ctx.fill();
      // Barrel
      ctx.rotate(b.angle);
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(0, -6, BOSS_TURRET.radius+18, 12);
      ctx.restore();
    }

    // Boss projectiles
    for (const s of state.bossShots){
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 2; ctx.stroke();
    }

    ctx.restore();

    // Boss HP bar (screen space, top center)
    const hp = state.current ? state.current.hp : 0;
    const maxHp = state.current ? state.current.maxHp : 1;
    const frac = Math.max(0, Math.min(1, hp / maxHp));
    const x = (canvas.width - HP_BAR.w)/2;
    const y = HP_BAR.y;

    ctx.fillStyle = HP_BAR.bg;
    ctx.fillRect(x, y, HP_BAR.w, HP_BAR.h);
    ctx.fillStyle = HP_BAR.fill;
    ctx.fillRect(x, y, HP_BAR.w * frac, HP_BAR.h);
    ctx.strokeStyle = HP_BAR.stroke;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, HP_BAR.w, HP_BAR.h);
  }

  // Hook into update/draw safely after original + overheat
  const origUpdate = window.update;
  const origDraw = window.draw;

  window.update = function(dt){
    // Spawn logic (one boss at a time)
    if (!state.active && gameState === 'playing'){
      if (!state.defeatedJet && score >= BOSS1_SCORE){
        spawnBossJet();
      } else if (state.defeatedJet && !state.defeatedTurret && score >= BOSS2_SCORE){
        spawnBossTurret();
      }
    }

    origUpdate(dt); // keep original behaviors
    bossUpdate(dt); // then boss behaviors
  };

  window.draw = function(){
    origDraw();     // original drawing first
    bossDraw();     // then boss overlays (boss & hp bar)
  };
})();
</script>

</body>
</html>

<!-- ========== APPENDED SCRIPTS (do not edit existing code above) ========== -->

<!-- 1) Debug score boost key: press B while playing to +5000 -->
<script>
(function(){
  window.addEventListener('keydown', function(e){
    if ((e.key === 'b' || e.key === 'B') && typeof gameState !== 'undefined' && gameState === 'playing'){
      if (typeof score !== 'undefined'){
        score += 5000;
        if (typeof scoreDisplay !== 'undefined' && scoreDisplay) scoreDisplay.textContent = score;
      }
    }
  });
})();
</script>

<!-- 2) Hearts (3 lives) + 1s invincibility + extra hit FX (append-only, fixed reset hook) -->
<script>
(function(){
  const MAX_HEARTS = 3;
  const INVINCIBILITY_MS = 1000;

  let hearts = MAX_HEARTS;
  let invincibleUntil = 0;
  let fx = [];
  let flashAlpha = 0;

  // UI container
  const heartsContainer = document.createElement('div');
  heartsContainer.style.position = 'absolute';
  heartsContainer.style.top = '16px';
  heartsContainer.style.left = '16px';
  heartsContainer.style.zIndex = '1001';
  heartsContainer.style.display = 'flex';
  heartsContainer.style.gap = '6px';
  heartsContainer.style.pointerEvents = 'none';
  document.body.appendChild(heartsContainer);

  function heart(op=1, sc=1){
    const d=document.createElement('div');
    d.style.opacity=op; d.style.transform=`scale(${sc})`;
    d.style.transition='opacity 0.2s ease, transform 0.2s ease';
    d.innerHTML=`<svg viewBox="0 0 24 24" width="24" height="24" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 21s-6.7-4.35-9.33-7.36C-0.48 10.35 1.2 5.7 5.07 5.07 7.3 4.7 9.1 6 12 8.6 14.9 6 16.7 4.7 18.93 5.07c3.86.63 5.55 5.28 2.4 8.57C18.7 16.65 12 21 12 21z"
            fill="#ef4444" stroke="#7f1d1d" stroke-width="1"/></svg>`;
    return d;
  }
  function renderHearts(){
    heartsContainer.innerHTML='';
    for(let i=0;i<MAX_HEARTS;i++){
      heartsContainer.appendChild(heart(i<hearts?1:0.25, i<hearts?1:0.9));
    }
  }
  renderHearts();

  // FX helpers
  function addSparks(x,y,color='#ffd54f',n=18){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2, s=140+Math.random()*160, l=0.22+Math.random()*0.35;
      fx.push({x,y,dx:Math.cos(a)*s,dy:Math.sin(a)*s,life:l,maxLife:l,size:2+Math.random()*3,color});
    }
  }
  function addSmoke(x,y,color='rgba(80,80,80,0.5)',n=10){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2, s=30+Math.random()*60, l=0.8+Math.random()*0.8;
      fx.push({x,y,dx:Math.cos(a)*s,dy:Math.sin(a)*s,life:l,maxLife:l,size:6+Math.random()*10,color});
    }
  }

  // ✅ Fixed reset hook — run original first, then restore hearts
  if (typeof window.resetGame === 'function'){
    const _r = window.resetGame;
    window.resetGame = function(){
      const result = _r.apply(this, arguments); // original reset
      hearts = MAX_HEARTS;
      invincibleUntil = 0;
      fx.length = 0;
      flashAlpha = 0;
      renderHearts();
      return result;
    };
  }

  // Turn first few “game over” events into damage + invincibility
  const _showGameOver = window.showGameOver;
  window.showGameOver = function(){
    const t = (typeof performance!=='undefined'?performance.now():Date.now());
    if (t < invincibleUntil) return;
    if (hearts > 1){
      hearts--;
      renderHearts();
      invincibleUntil = t + INVINCIBILITY_MS;
      flashAlpha = 0.35;
      if (typeof player !== 'undefined'){ addSparks(player.x,player.y,'#f87171',26); addSmoke(player.x,player.y,'rgba(255,120,120,0.35)',14); }
      return; // consume a heart; do not end game
    }
    _showGameOver(); // out of hearts → normal game over
  };

  // Draw hook: overlay FX + flash
  const _draw = window.draw;
  window.draw = function(){
    _draw();

    // white flash
    if (flashAlpha>0){
      ctx.save(); ctx.globalAlpha = flashAlpha; ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();
      flashAlpha = Math.max(0, flashAlpha - 0.06);
    }

    // particles in screen coords
    const dt = 1/60;
    for(let i=fx.length-1;i>=0;i--){
      const p=fx[i];
      p.x+=p.dx*dt; p.y+=p.dy*dt; p.life-=dt;
      if(p.life<=0){ fx.splice(i,1); continue; }
      const a=p.life/p.maxLife;
      const sx = p.x - camera.x + canvas.width/2;
      const sy = p.y - camera.y + canvas.height/2;
      ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=p.color;
      ctx.beginPath(); ctx.arc(sx,sy,p.size,0,Math.PI*2); ctx.fill(); ctx.restore();
    }
  };

  // Update hook: ambient smoke when low hearts
  const _update = window.update;
  window.update = function(dt){
    _update(dt);
    if (typeof gameState!=='undefined' && gameState==='playing' && hearts===1 && Math.random()<0.05 && typeof player!=='undefined'){
      addSmoke(player.x,player.y,'rgba(80,80,80,0.6)',2);
    }
  };
})();
</script>
<script>
window.addEventListener('load', function(){
  const btn = document.getElementById('restartButton');
  if (btn && typeof window.resetGame === 'function'){
    btn.removeEventListener('click', resetGame);
    btn.addEventListener('click', () => window.resetGame());
  }
});
</script>

